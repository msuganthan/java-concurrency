The class `java.util.concurrent.ThreadLocalRandom` is derived from `java.util.Random` and generates random numbers much more efficiently than `java.util.Random` in multithreaded scenarios. To understand it:

```
protected int next(int bits) {
    long oldseed, nextseed:
    AtomicLong seed = this.seed;
    do {
        oldseed = seed.get();
        nextseed = (oldseed * mulitplier + addend) & mask;
    }while(!seed.compareAndSet(oldseed, nextseed));
    return (int)(nextseed >>> (48 - bits));
}
```

The `do-while` loop uses the `compareAndSet()` method to atomically set the seed variable to new value in its predicate. Imagine several threads invoking the `next()` method on a shared instance of `Random`, only one will thread successfully exit the loop and the rest will `re-execute` the loop, until all of them exit one-by-one. This mechanism to update the seed variable is precisely what makes the `Random` class inefficient for highly concurrent programs.

The `ThreadLocalRandom` has no bearing on random number generated by other threads. The `ThreadLocalRandom` class is singleton and uses state held by the `Thread` class to generate random numbers. In particular the `Thread` class houses the following fields for `ThreadLocalRandom` to use for generating random numbers and related book-keeping.


```
class Thread implements Runnable {
    //The current seed for a ThreadLocalRandom
    long threadLocalRandomSeed;
    
    //Probe hash value, non-zero if threadLocalRandomSeed initialized
    int threadLocalRandomProbe;
    
    //Secondary seed isolated from public ThreadLocalRandom sequence
    int threadLocalRandomSecondarySeed;
}
```